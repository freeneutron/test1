{"ts":1368880135757,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"(function(\n\tuserConfig,\n\tdefaultConfig\n){\n\t// summary:\n\t//\t\tThis is the \"source loader\" and is the entry point for Dojo during development. You may also load Dojo with\n\t//\t\tany AMD-compliant loader via the package main module dojo/main.\n\t// description:\n\t//\t\tThis is the \"source loader\" for Dojo. It provides an AMD-compliant loader that can be configured\n\t//\t\tto operate in either synchronous or asynchronous modes. After the loader is defined, dojo is loaded\n\t//\t\tIAW the package main module dojo/main. In the event you wish to use a foreign loader, you may load dojo as a package\n\t//\t\tvia the package main module dojo/main and this loader is not required; see dojo/package.json for details.\n\t//\n\t//\t\tIn order to keep compatibility with the v1.x line, this loader includes additional machinery that enables\n\t//\t\tthe dojo.provide, dojo.require et al API. This machinery is loaded by default, but may be dynamically removed\n\t//\t\tvia the has.js API and statically removed via the build system.\n\t//\n\t//\t\tThis loader includes sniffing machinery to determine the environment; the following environments are supported:\n\t//\n\t//\t\t- browser\n\t//\t\t- node.js\n\t//\t\t- rhino\n\t//\n\t//\t\tThis is the so-called \"source loader\". As such, it includes many optional features that may be discadred by\n\t//\t\tbuilding a customized verion with the build system.\n\n\t// Design and Implementation Notes\n\t//\n\t// This is a dojo-specific adaption of bdLoad, donated to the dojo foundation by Altoviso LLC.\n\t//\n\t// This function defines an AMD-compliant (http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition)\n\t// loader that can be configured to operate in either synchronous or asynchronous modes.\n\t//\n\t// Since this machinery implements a loader, it does not have the luxury of using a load system and/or\n\t// leveraging a utility library. This results in an unpleasantly long file; here is a road map of the contents:\n\t//\n\t//\t 1. Small library for use implementing the loader.\n\t//\t 2. Define the has.js API; this is used throughout the loader to bracket features.\n\t//\t 3. Define the node.js and rhino sniffs and sniff.\n\t//\t 4. Define the loader's data.\n\t//\t 5. Define the configuration machinery.\n\t//\t 6. Define the script element sniffing machinery and sniff for configuration data.\n\t//\t 7. Configure the loader IAW the provided user, default, and sniffing data.\n\t//\t 8. Define the global require function.\n\t//\t 9. Define the module resolution machinery.\n\t//\t10. Define the module and plugin module definition machinery\n\t//\t11. Define the script injection machinery.\n\t//\t12. Define the window load detection.\n\t//\t13. Define the logging API.\n\t//\t14. Define the tracing API.\n\t//\t16. Define the AMD define function.\n\t//\t17. Define the dojo v1.x provide/require machinery--so called \"legacy\" modes.\n\t//\t18. Publish global variables.\n\t//\n\t// Language and Acronyms and Idioms\n\t//\n\t// moduleId: a CJS module identifier, (used for public APIs)\n\t// mid: moduleId (used internally)\n\t// packageId: a package identifier (used for public APIs)\n\t// pid: packageId (used internally); the implied system or default package has pid===\"\"\n\t// pack: package is used internally to reference a package object (since javascript has reserved words including \"package\")\n\t// prid: plugin resource identifier\n\t// The integer constant 1 is used in place of true and 0 in place of false.\n\n\t// define a minimal library to help build the loader\n\tvar\tnoop = function(){\n\t\t},\n\n\t\tisEmpty = function(it){\n\t\t\tfor(var p in it){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t},\n\n\t\ttoString = {}.toString,\n\n\t\tisFunction = function(it){\n\t\t\treturn toString.call(it) == \"[object Function]\";\n\t\t},\n\n\t\tisString = function(it){\n\t\t\treturn toString.call(it) == \"[object String]\";\n\t\t},\n\n\t\tisArray = function(it){\n\t\t\treturn toString.call(it) == \"[object Array]\";\n\t\t},\n\n\t\tforEach = function(vector, callback){\n\t\t\tif(vector){\n\t\t\t\tfor(var i = 0; i < vector.length;){\n\t\t\t\t\tcallback(vector[i++]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmix = function(dest, src){\n\t\t\tfor(var p in src){\n\t\t\t\tdest[p] = src[p];\n\t\t\t}\n\t\t\treturn dest;\n\t\t},\n\n\t\tmakeError = function(error, info){\n\t\t\treturn mix(new Error(error), {src:\"dojoLoader\", info:info});\n\t\t},\n\n\t\tuidSeed = 1,\n\n\t\tuid = function(){\n\t\t\t// Returns a unique indentifier (within the lifetime of the document) of the form /_d+/.\n\t\t\treturn \"_\" + uidSeed++;\n\t\t},\n\n\t\t// FIXME: how to doc window.require() api\n\n\t\t// this will be the global require function; define it immediately so we can start hanging things off of it\n\t\treq = function(\n\t\t\tconfig,\t\t  //(object, optional) hash of configuration properties\n\t\t\tdependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before applying callback\n\t\t\tcallback\t  //(function, optional) lamda expression to apply to module values implied by dependencies\n\t\t){\n\t\t\treturn contextRequire(config, dependencies, callback, 0, req);\n\t\t},\n\n\t\t// the loader uses the has.js API to control feature inclusion/exclusion; define then use throughout\n\t\tglobal = this,\n\n\t\tdoc = global.document,\n\n\t\telement = doc && doc.createElement(\"DiV\"),\n\n\t\thas = req.has = function(name){\n\t\t\treturn isFunction(hasCache[name]) ? (hasCache[name] = hasCache[name](global, doc, element)) : hasCache[name];\n\t\t},\n\n\t\thasCache = has.cache = defaultConfig.hasCache;\n\n\thas.add = function(name, test, now, force){\n\t\t(hasCache[name]===undefined || force) && (hasCache[name] = test);\n\t\treturn now && has(name);\n\t};\n\n\thas.add(\"host-node\", userConfig.has && \"host-node\" in userConfig.has ?\n\t\tuserConfig.has[\"host-node\"] :\n\t\t(typeof process == \"object\" && process.versions && process.versions.node && process.versions.v8));\n\tif(has(\"host-node\")){\n\t\t// fixup the default config for node.js environment\n\t\trequire(\"./_base/configNode.js\").config(defaultConfig);\n\t\t// remember node's require (with respect to baseUrl==dojo's root)\n\t\tdefaultConfig.loaderPatch.nodeRequire = require;\n\t}\n\n\thas.add(\"host-rhino\", userConfig.has && \"host-rhino\" in userConfig.has ?\n\t\tuserConfig.has[\"host-rhino\"] :\n\t\t(typeof load == \"function\" && (typeof Packages == \"function\" || typeof Packages == \"object\")));\n\tif(has(\"host-rhino\")){\n\t\t// owing to rhino's lame feature that hides the source of the script, give the user a way to specify the baseUrl...\n\t\tfor(var baseUrl = userConfig.baseUrl || \".\", arg, rhinoArgs = this.arguments, i = 0; i < rhinoArgs.length;){\n\t\t\targ = (rhinoArgs[i++] + \"\").split(\"=\");\n\t\t\tif(arg[0] == \"baseUrl\"){\n\t\t\t\tbaseUrl = arg[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tload(baseUrl + \"/_base/configRhino.js\");\n\t\trhinoDojoConfig(defaultConfig, baseUrl, rhinoArgs);\n\t}\n\n\t// userConfig has tests override defaultConfig has tests; do this after the environment detection because\n\t// the environment detection usually sets some has feature values in the hasCache.\n\tfor(var p in userConfig.has){\n\t\thas.add(p, userConfig.has[p], 0, 1);\n\t}\n\n\t//\n\t// define the loader data\n\t//\n\n\t// the loader will use these like symbols if the loader has the traceApi; otherwise\n\t// define magic numbers so that modules can be provided as part of defaultConfig\n\tvar\trequested = 1,\n\t\tarrived = 2,\n\t\tnonmodule = 3,\n\t\texecuting = 4,\n\t\texecuted = 5;\n\n\tif(has(\"dojo-trace-api\")){\n\t\t// these make debugging nice; but using strings for symbols is a gross rookie error; don't do it for production code\n\t\trequested = \"requested\";\n\t\tarrived = \"arrived\";\n\t\tnonmodule = \"not-a-module\";\n\t\texecuting = \"executing\";\n\t\texecuted = \"executed\";\n\t}\n\n\tvar legacyMode = 0,\n\t\tsync = \"sync\",\n\t\txd = \"xd\",\n\t\tsyncExecStack = [],\n\t\tdojoRequirePlugin = 0,\n\t\tcheckDojoRequirePlugin = noop,\n\t\ttransformToAmd = noop,\n\t\tgetXhr;\n\tif(has(\"dojo-sync-loader\")){\n\t\treq.isXdUrl = noop;\n\n\t\treq.initSyncLoader = function(dojoRequirePlugin_, checkDojoRequirePlugin_, transformToAmd_){\n\t\t\t// the first dojo/_base/loader loaded gets to define these variables; they are designed to work\n\t\t\t// in the presense of zero to many mapped dojo/_base/loaders\n\t\t\tif(!dojoRequirePlugin){\n\t\t\t\tdojoRequirePlugin = dojoRequirePlugin_;\n\t\t\t\tcheckDojoRequirePlugin = checkDojoRequirePlugin_;\n\t\t\t\ttransformToAmd = transformToAmd_;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tsync:sync,\n\t\t\t\trequested:requested,\n\t\t\t\tarrived:arrived,\n\t\t\t\tnonmodule:nonmodule,\n\t\t\t\texecuting:executing,\n\t\t\t\texecuted:executed,\n\t\t\t\tsyncExecStack:syncExecStack,\n\t\t\t\tmodules:modules,\n\t\t\t\texecQ:execQ,\n\t\t\t\tgetModule:getModule,\n\t\t\t\tinjectModule:injectModule,\n\t\t\t\tsetArrived:setArrived,\n\t\t\t\tsignal:signal,\n\t\t\t\tfinishExec:finishExec,\n\t\t\t\texecModule:execModule,\n\t\t\t\tdojoRequirePlugin:dojoRequirePlugin,\n\t\t\t\tgetLegacyMode:function(){return legacyMode;},\n\t\t\t\tguardCheckComplete:guardCheckComplete\n\t\t\t};\n\t\t};\n\n\t\tif(has(\"dom\")){\n\t\t\t// in legacy sync mode, the loader needs a minimal XHR library\n\n\t\t\tvar locationProtocol = location.protocol,\n\t\t\t\tlocationHost = location.host;\n\t\t\treq.isXdUrl = function(url){\n\t\t\t\tif(/^\\./.test(url)){\n\t\t\t\t\t// begins with a dot is always relative to page URL; therefore not xdomain\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(/^\\/\\//.test(url)){\n\t\t\t\t\t// for v1.6- backcompat, url starting with // indicates xdomain\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// get protocol and host\n\t\t\t\t// \\/+ takes care of the typical file protocol that looks like file:///drive/path/to/file\n\t\t\t\t// locationHost is falsy if file protocol => if locationProtocol matches and is \"file:\", || will return false\n\t\t\t\tvar match = url.match(/^([^\\/\\:]+\\:)\\/+([^\\/]+)/);\n\t\t\t\treturn match && (match[1] != locationProtocol || (locationHost && match[2] != locationHost));\n\t\t\t};\n\n\n\t\t\t// note: to get the file:// protocol to work in FF, you must set security.fileuri.strict_origin_policy to false in about:config\n\t\t\thas.add(\"dojo-xhr-factory\", 1);\n\t\t\thas.add(\"dojo-force-activex-xhr\", has(\"host-browser\") && !doc.addEventListener && window.location.protocol == \"file:\");\n\t\t\thas.add(\"native-xhr\", typeof XMLHttpRequest != \"undefined\");\n\t\t\tif(has(\"native-xhr\") && !has(\"dojo-force-activex-xhr\")){\n\t\t\t\tgetXhr = function(){\n\t\t\t\t\treturn new XMLHttpRequest();\n\t\t\t\t};\n\t\t\t}else{\n\t\t\t\t// if in the browser an old IE; find an xhr\n\t\t\t\tfor(var XMLHTTP_PROGIDS = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'], progid, i = 0; i < 3;){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tprogid = XMLHTTP_PROGIDS[i++];\n\t\t\t\t\t\tif(new ActiveXObject(progid)){\n\t\t\t\t\t\t\t// this progid works; therefore, use it from now on\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t// squelch; we're just trying to find a good ActiveX progid\n\t\t\t\t\t\t// if they all fail, then progid ends up as the last attempt and that will signal the error\n\t\t\t\t\t\t// the first time the client actually tries to exec an xhr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgetXhr = function(){\n\t\t\t\t\treturn new ActiveXObject(progid);\n\t\t\t\t};\n\t\t\t}\n\t\t\treq.getXhr = getXhr;\n\n\t\t\thas.add(\"dojo-gettext-api\", 1);\n\t\t\treq.getText = function(url, async, onLoad){\n\t\t\t\tvar xhr = getXhr();\n\t\t\t\txhr.open('GET', fixupUrl(url), false);\n\t\t\t\txhr.send(null);\n\t\t\t\tif(xhr.status == 200 || (!location.host && !xhr.status)){\n\t\t\t\t\tif(onLoad){\n\t\t\t\t\t\tonLoad(xhr.responseText, async);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tthrow makeError(\"xhrFailed\", xhr.status);\n\t\t\t\t}\n\t\t\t\treturn xhr.responseText;\n\t\t\t};\n\t\t}\n\t}else{\n\t\treq.async = 1;\n\t}\n\n\t//\n\t// loader eval\n\t//\n\tvar eval_ =\n\t\t// use the function constructor so our eval is scoped close to (but not in) in the global space with minimal pollution\n\t\tnew Function('return eval(arguments[0]);');\n\n\treq.eval =\n\t\tfunction(text, hint){\n\t\t\treturn eval_(text + \"\\r\\n////@ sourceURL=\" + hint);\n\t\t};\n\n\t//\n\t// loader micro events API\n\t//\n\tvar listenerQueues = {},\n\t\terror = \"error\",\n\t\tsignal = req.signal = function(type, args){\n\t\t\tvar queue = listenerQueues[type];\n\t\t\t// notice we run a copy of the queue; this allows listeners to add/remove\n\t\t\t// other listeners without affecting this particular signal\n\t\t\tforEach(queue && queue.slice(0), function(listener){\n\t\t\t\tlistener.apply(null, isArray(args) ? args : [args]);\n\t\t\t});\n\t\t},\n\t\ton = req.on = function(type, listener){\n\t\t\t// notice a queue is not created until a client actually connects\n\t\t\tvar queue = listenerQueues[type] || (listenerQueues[type] = []);\n\t\t\tqueue.push(listener);\n\t\t\treturn {\n\t\t\t\tremove:function(){\n\t\t\t\t\tfor(var i = 0; i<queue.length; i++){\n\t\t\t\t\t\tif(queue[i]===listener){\n\t\t\t\t\t\t\tqueue.splice(i, 1);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t// configuration machinery; with an optimized/built defaultConfig, all configuration machinery can be discarded\n\t// lexical variables hold key loader data structures to help with minification; these may be completely,\n\t// one-time initialized by defaultConfig for optimized/built versions\n\tvar\n\t\taliases\n\t\t\t// a vector of pairs of [regexs or string, replacement] => (alias, actual)\n\t\t\t= [],\n\n\t\tpaths\n\t\t\t// CommonJS paths\n\t\t\t= {},\n\n\t\tpathsMapProg\n\t\t\t// list of (from-path, to-path, regex, length) derived from paths;\n\t\t\t// a \"program\" to apply paths; see computeMapProg\n\t\t\t= [],\n\n\t\tpacks\n\t\t\t// a map from packageId to package configuration object; see fixupPackageInfo\n\t\t\t= {},\n\n\t\tmap = req.map\n\t\t\t// AMD map config variable; dojo/_base/kernel needs req.map to figure out the scope map\n\t\t\t= {},\n\n\t\tmapProgs\n\t\t\t// vector of quads as described by computeMapProg; map-key is AMD map key, map-value is AMD map value\n\t\t\t= [],\n\n\t\tmodules\n\t\t\t// A hash:(mid) --> (module-object) the module namespace\n\t\t\t//\n\t\t\t// pid: the package identifier to which the module belongs (e.g., \"dojo\"); \"\" indicates the system or default package\n\t\t\t// mid: the fully-resolved (i.e., mappings have been applied) module identifier without the package identifier (e.g., \"dojo/io/script\")\n\t\t\t// url: the URL from which the module was retrieved\n\t\t\t// pack: the package object of the package to which the module belongs\n\t\t\t// executed: 0 => not executed; executing => in the process of tranversing deps and running factory; executed => factory has been executed\n\t\t\t// deps: the dependency vector for this module (vector of modules objects)\n\t\t\t// def: the factory for this module\n\t\t\t// result: the result of the running the factory for this module\n\t\t\t// injected: (0 | requested | arrived) the status of the module; nonmodule means the resource did not call define\n\t\t\t// load: plugin load function; applicable only for plugins\n\t\t\t//\n\t\t\t// Modules go through several phases in creation:\n\t\t\t//\n\t\t\t// 1. Requested: some other module's definition or a require application contained the requested module in\n\t\t\t//\t  its dependency vector or executing code explicitly demands a module via req.require.\n\t\t\t//\n\t\t\t// 2. Injected: a script element has been appended to the insert-point element demanding the resource implied by the URL\n\t\t\t//\n\t\t\t// 3. Loaded: the resource injected in [2] has been evalated.\n\t\t\t//\n\t\t\t// 4. Defined: the resource contained a define statement that advised the loader about the module. Notice that some\n\t\t\t//\t  resources may just contain a bundle of code and never formally define a module via define\n\t\t\t//\n\t\t\t// 5. Evaluated: the module was defined via define and the loader has evaluated the factory and computed a result.\n\t\t\t= {},\n\n\t\tcacheBust\n\t\t\t// query string to append to module URLs to bust browser cache\n\t\t\t= \"\",\n\n\t\tcache\n\t\t\t// hash:(mid | url)-->(function | string)\n\t\t\t//\n\t\t\t// A cache of resources. The resources arrive via a config.cache object, which is a hash from either mid --> function or\n\t\t\t// url --> string. The url key is distinguished from the mid key by always containing the prefix \"url:\". url keys as provided\n\t\t\t// by config.cache always have a string value that represents the contents of the resource at the given url. mid keys as provided\n\t\t\t// by configl.cache always have a function value that causes the same code to execute as if the module was script injected.\n\t\t\t//\n\t\t\t// Both kinds of key-value pairs are entered into cache via the function consumePendingCache, which may relocate keys as given\n\t\t\t// by any mappings *iff* the config.cache was received as part of a module resource request.\n\t\t\t//\n\t\t\t// Further, for mid keys, the implied url is computed and the value is entered into that key as well. This allows mapped modules\n\t\t\t// to retrieve cached items that may have arrived consequent to another namespace.\n\t\t\t//\n\t\t\t = {},\n\n\t\turlKeyPrefix\n\t\t\t// the prefix to prepend to a URL key in the cache.\n\t\t\t= \"url:\",\n\n\t\tpendingCacheInsert\n\t\t\t// hash:(mid)-->(function)\n\t\t\t//\n\t\t\t// Gives a set of cache modules pending entry into cache. When cached modules are published to the loader, they are\n\t\t\t// entered into pendingCacheInsert; modules are then pressed into cache upon (1) AMD define or (2) upon receiving another\n\t\t\t// independent set of cached modules. (1) is the usual case, and this case allows normalizing mids given in the pending\n\t\t\t// cache for the local configuration, possibly relocating modules.\n\t\t\t = {},\n\n\t\tdojoSniffConfig\n\t\t\t// map of configuration variables\n\t\t\t// give the data-dojo-config as sniffed from the document (if any)\n\t\t\t= {};\n\n\tif(has(\"dojo-config-api\")){\n\t\tvar consumePendingCacheInsert = function(referenceModule){\n\t\t\t\tvar p, item, match, now, m;\n\t\t\t\tfor(p in pendingCacheInsert){\n\t\t\t\t\titem = pendingCacheInsert[p];\n\t\t\t\t\tmatch = p.match(/^url\\:(.+)/);\n\t\t\t\t\tif(match){\n\t\t\t\t\t\tcache[urlKeyPrefix + toUrl(match[1], referenceModule)] =  item;\n\t\t\t\t\t}else if(p==\"*now\"){\n\t\t\t\t\t\tnow = item;\n\t\t\t\t\t}else if(p!=\"*noref\"){\n\t\t\t\t\t\tm = getModuleInfo(p, referenceModule);\n\t\t\t\t\t\tcache[m.mid] = cache[urlKeyPrefix + m.url] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(now){\n\t\t\t\t\tnow(createRequire(referenceModule));\n\t\t\t\t}\n\t\t\t\tpendingCacheInsert = {};\n\t\t\t},\n\n\t\t\tescapeString = function(s){\n\t\t\t\treturn s.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, function(c){ return \"\\\\\" + c; });\n\t\t\t},\n\n\t\t\tcomputeMapProg = function(map, dest){\n\t\t\t\t// This routine takes a map as represented by a JavaScript object and initializes dest, a vector of\n\t\t\t\t// quads of (map-key, map-value, refex-for-map-key, length-of-map-key), sorted decreasing by length-\n\t\t\t\t// of-map-key. The regex looks for the map-key followed by either \"/\" or end-of-string at the beginning\n\t\t\t\t// of a the search source. Notice the map-value is irrelevent to the algorithm\n\t\t\t\tdest.splice(0, dest.length);\n\t\t\t\tfor(var p in map){\n\t\t\t\t\tdest.push([\n\t\t\t\t\t\tp,\n\t\t\t\t\t\tmap[p],\n\t\t\t\t\t\tnew RegExp(\"^\" + escapeString(p) + \"(\\/|$)\"),\n\t\t\t\t\t\tp.length]);\n\t\t\t\t}\n\t\t\t\tdest.sort(function(lhs, rhs){ return rhs[3] - lhs[3]; });\n\t\t\t\treturn dest;\n\t\t\t},\n\n\t\t\tfixupPackageInfo = function(packageInfo){\n\t\t\t\t// calculate the precise (name, location, main, mappings) for a package\n\t\t\t\tvar name = packageInfo.name;\n\t\t\t\tif(!name){\n\t\t\t\t\t// packageInfo must be a string that gives the name\n\t\t\t\t\tname = packageInfo;\n\t\t\t\t\tpackageInfo = {name:name};\n\t\t\t\t}\n\t\t\t\tpackageInfo = mix({main:\"main\"}, packageInfo);\n\t\t\t\tpackageInfo.location = packageInfo.location ? packageInfo.location : name;\n\n\t\t\t\t// packageMap is depricated in favor of AMD map\n\t\t\t\tif(packageInfo.packageMap){\n\t\t\t\t\tmap[name] = packageInfo.packageMap;\n\t\t\t\t}\n\n\t\t\t\tif(!packageInfo.main.indexOf(\"./\")){\n\t\t\t\t\tpackageInfo.main = packageInfo.main.substring(2);\n\t\t\t\t}\n\n\t\t\t\t// now that we've got a fully-resolved package object, push it into the configuration\n\t\t\t\tpacks[name] = packageInfo;\n\t\t\t},\n\n\t\t\tdelayedModuleConfig\n\t\t\t\t// module config cannot be consummed until the loader is completely initialized; therefore, all\n\t\t\t\t// module config detected during booting is memorized and applied at the end of loader initialization\n\t\t\t\t// TODO: this is a bit of a kludge; all config should be moved to end of loader initialization, but\n\t\t\t\t// we'll delay this chore and do it with a final loader 1.x cleanup after the 2.x loader prototyping is complete\n\t\t\t\t= [],\n\n\n\t\t\tconfig = function(config, booting, referenceModule){\n\t\t\t\tfor(var p in config){\n\t\t\t\t\tif(p==\"waitSeconds\"){\n\t\t\t\t\t\treq.waitms = (config[p] || 0) * 1000;\n\t\t\t\t\t}\n\t\t\t\t\tif(p==\"cacheBust\"){\n\t\t\t\t\t\tcacheBust = config[p] ? (isString(config[p]) ? config[p] : (new Date()).getTime() + \"\") : \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif(p==\"baseUrl\" || p==\"combo\"){\n\t\t\t\t\t\treq[p] = config[p];\n\t\t\t\t\t}\n\t\t\t\t\tif(has(\"dojo-sync-loader\") && p==\"async\"){\n\t\t\t\t\t\t// falsy or \"sync\" => legacy sync loader\n\t\t\t\t\t\t// \"xd\" => sync but loading xdomain tree and therefore loading asynchronously (not configurable, set automatically by the loader)\n\t\t\t\t\t\t// \"legacyAsync\" => permanently in \"xd\" by choice\n\t\t\t\t\t\t// \"debugAtAllCosts\" => trying to load everything via script injection (not implemented)\n\t\t\t\t\t\t// otherwise, must be truthy => AMD\n\t\t\t\t\t\t// legacyMode: sync | legacyAsync | xd | false\n\t\t\t\t\t\tvar mode = config[p];\n\t\t\t\t\t\treq.legacyMode = legacyMode = (isString(mode) && /sync|legacyAsync/.test(mode) ? mode : (!mode ? sync : false));\n\t\t\t\t\t\treq.async = !legacyMode;\n\t\t\t\t\t}\n\t\t\t\t\tif(config[p]!==hasCache){\n\t\t\t\t\t\t// accumulate raw config info for client apps which can use this to pass their own config\n\t\t\t\t\t\treq.rawConfig[p] = config[p];\n\t\t\t\t\t\tp!=\"has\" && has.add(\"config-\"+p, config[p], 0, booting);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// make sure baseUrl exists\n\t\t\t\tif(!req.baseUrl){\n\t\t\t\t\treq.baseUrl = \"./\";\n\t\t\t\t}\n\t\t\t\t// make sure baseUrl ends with a slash\n\t\t\t\tif(!/\\/$/.test(req.baseUrl)){\n\t\t\t\t\treq.baseUrl += \"/\";\n\t\t\t\t}\n\n\t\t\t\t// now do the special work for has, packages, packagePaths, paths, aliases, and cache\n\n\t\t\t\tfor(p in config.has){\n\t\t\t\t\thas.add(p, config.has[p], 0, booting);\n\t\t\t\t}\n\n\t\t\t\t// for each package found in any packages config item, augment the packs map owned by the loader\n\t\t\t\tforEach(config.packages, fixupPackageInfo);\n\n\t\t\t\t// for each packagePath found in any packagePaths config item, augment the packageConfig\n\t\t\t\t// packagePaths is depricated; remove in 2.0\n\t\t\t\tfor(baseUrl in config.packagePaths){\n\t\t\t\t\tforEach(config.packagePaths[baseUrl], function(packageInfo){\n\t\t\t\t\t\tvar location = baseUrl + \"/\" + packageInfo;\n\t\t\t\t\t\tif(isString(packageInfo)){\n\t\t\t\t\t\t\tpackageInfo = {name:packageInfo};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpackageInfo.location = location;\n\t\t\t\t\t\tfixupPackageInfo(packageInfo);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// notice that computeMapProg treats the dest as a reference; therefore, if/when that variable\n\t\t\t\t// is published (see dojo-publish-privates), the published variable will always hold a valid value.\n\n\t\t\t\t// this must come after all package processing since package processing may mutate map\n\t\t\t\tcomputeMapProg(mix(map, config.map), mapProgs);\n\t\t\t\tforEach(mapProgs, function(item){\n\t\t\t\t\titem[1] = computeMapProg(item[1], []);\n\t\t\t\t\tif(item[0]==\"*\"){\n\t\t\t\t\t\tmapProgs.star = item;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// push in any paths and recompute the internal pathmap\n\t\t\t\tcomputeMapProg(mix(paths, config.paths), pathsMapProg);\n\n\t\t\t\t// aliases\n\t\t\t\tforEach(config.aliases, function(pair){\n\t\t\t\t\tif(isString(pair[0])){\n\t\t\t\t\t\tpair[0] = new RegExp(\"^\" + escapeString(pair[0]) + \"$\");\n\t\t\t\t\t}\n\t\t\t\t\taliases.push(pair);\n\t\t\t\t});\n\n\t\t\t\tif(booting){\n\t\t\t\t\tdelayedModuleConfig.push({config:config.config});\n\t\t\t\t}else{\n\t\t\t\t\tfor(p in config.config){\n\t\t\t\t\t\tvar module = getModule(p, referenceModule);\n\t\t\t\t\t\tmodule.config = mix(module.config || {}, config.config[p]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// push in any new cache values\n\t\t\t\tif(config.cache){\n\t\t\t\t\tconsumePendingCacheInsert();\n\t\t\t\t\tpendingCacheInsert = config.cache;\n\t\t\t\t\tif(config.cache[\"*noref\"]){\n\t\t\t\t\t\tconsumePendingCacheInsert();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsignal(\"config\", [config, req.rawConfig]);\n\t\t\t};\n\n\t\t//\n\t\t// execute the various sniffs; userConfig can override and value\n\t\t//\n\n\t\tif(has(\"dojo-cdn\") || has(\"dojo-sniff\")){\n\t\t\t// the sniff regex looks for a src attribute ending in dojo.js, optionally preceeded with a path.\n\t\t\t// match[3] returns the path to dojo.js (if any) without the trailing slash. This is used for the\n\t\t\t// dojo location on CDN deployments and baseUrl when either/both of these are not provided\n\t\t\t// explicitly in the config data; this is the 1.6- behavior.\n\n\t\t\tvar scripts = doc.getElementsByTagName(\"script\"),\n\t\t\t\ti = 0,\n\t\t\t\tscript, dojoDir, src, match;\n\t\t\twhile(i < scripts.length){\n\t\t\t\tscript = scripts[i++];\n\t\t\t\tif((src = script.getAttribute(\"src\")) && (match = src.match(/(((.*)\\/)|^)dojo\\.js(\\W|$)/i))){\n\t\t\t\t\t// sniff dojoDir and baseUrl\n\t\t\t\t\tdojoDir = match[3] || \"\";\n\t\t\t\t\tdefaultConfig.baseUrl = defaultConfig.baseUrl || dojoDir;\n\n\t\t\t\t\t// sniff configuration on attribute in script element\n\t\t\t\t\tsrc = (script.getAttribute(\"data-dojo-config\") || script.getAttribute(\"djConfig\"));\n\t\t\t\t\tif(src){\n\t\t\t\t\t\tdojoSniffConfig = req.eval(\"({ \" + src + \" })\", \"data-dojo-config\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// sniff requirejs attribute\n\t\t\t\t\tif(has(\"dojo-requirejs-api\")){\n\t\t\t\t\t\tvar dataMain = script.getAttribute(\"data-main\");\n\t\t\t\t\t\tif(dataMain){\n\t\t\t\t\t\t\tdojoSniffConfig.deps = dojoSniffConfig.deps || [dataMain];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(has(\"dojo-test-sniff\")){\n\t\t\t// pass down doh.testConfig from parent as if it were a data-dojo-config\n\t\t\ttry{\n\t\t\t\tif(window.parent != window && window.parent.require){\n\t\t\t\t\tvar doh = window.parent.require(\"doh\");\n\t\t\t\t\tdoh && mix(dojoSniffConfig, doh.testConfig);\n\t\t\t\t}\n\t\t\t}catch(e){}\n\t\t}\n\n\t\t// configure the loader; let the user override defaults\n\t\treq.rawConfig = {};\n\t\tconfig(defaultConfig, 1);\n\n\t\t// do this before setting userConfig/sniffConfig to allow userConfig/sniff overrides\n\t\tif(has(\"dojo-cdn\")){\n\t\t\tpacks.dojo.location = dojoDir;\n\t\t\tif(dojoDir){\n\t\t\t\tdojoDir += \"/\";\n\t\t\t}\n\t\t\tpacks.dijit.location = dojoDir + \"../dijit/\";\n\t\t\tpacks.dojox.location = dojoDir + \"../dojox/\";\n\t\t}\n\n\t\tconfig(userConfig, 1);\n\t\tconfig(dojoSniffConfig, 1);\n\n\t}else{\n\t\t// no config API, assume defaultConfig has everything the loader needs...for the entire lifetime of the application\n\t\tpaths = defaultConfig.paths;\n\t\tpathsMapProg = defaultConfig.pathsMapProg;\n\t\tpacks = defaultConfig.packs;\n\t\taliases = defaultConfig.aliases;\n\t\tmapProgs = defaultConfig.mapProgs;\n\t\tmodules = defaultConfig.modules;\n\t\tcache = defaultConfig.cache;\n\t\tcacheBust = defaultConfig.cacheBust;\n\n\t\t// remember the default config for other processes (e.g., dojo/config)\n\t\treq.rawConfig = defaultConfig;\n\t}\n\n\n\tif(has(\"dojo-combo-api\")){\n\t\treq.combo = req.combo || {add:noop};\n\t\tvar\tcomboPending = 0,\n\t\t\tcombosPending = [],\n\t\t\tcomboPendingTimer = null;\n\t}\n\n\n\t// build the loader machinery iaw configuration, including has feature tests\n\tvar\tinjectDependencies = function(module){\n\t\t\t// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies\n\t\t\tguardCheckComplete(function(){\n\t\t\t\tforEach(module.deps, injectModule);\n\t\t\t\tif(has(\"dojo-combo-api\") && comboPending && !comboPendingTimer){\n\t\t\t\t\tcomboPendingTimer = setTimeout(function() {\n\t\t\t\t\t\tcomboPending = 0;\n\t\t\t\t\t\tcomboPendingTimer = null;\n\t\t\t\t\t\treq.combo.done(function(mids, url) {\n\t\t\t\t\t\t\tvar onLoadCallback= function(){\n\t\t\t\t\t\t\t\t// defQ is a vector of module definitions 1-to-1, onto mids\n\t\t\t\t\t\t\t\trunDefQ(0, mids);\n\t\t\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcombosPending.push(mids);\n\t\t\t\t\t\t\tinjectingModule = mids;\n\t\t\t\t\t\t\treq.injectUrl(url, onLoadCallback, mids);\n\t\t\t\t\t\t\tinjectingModule = 0;\n\t\t\t\t\t\t}, req);\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tcontextRequire = function(a1, a2, a3, referenceModule, contextRequire){\n\t\t\tvar module, syntheticMid;\n\t\t\tif(isString(a1)){\n\t\t\t\t// signature is (moduleId)\n\t\t\t\tmodule = getModule(a1, referenceModule, true);\n\t\t\t\tif(module && module.executed){\n\t\t\t\t\treturn module.result;\n\t\t\t\t}\n\t\t\t\tthrow makeError(\"undefinedModule\", a1);\n\t\t\t}\n\t\t\tif(!isArray(a1)){\n\t\t\t\t// a1 is a configuration\n\t\t\t\tconfig(a1, 0, referenceModule);\n\n\t\t\t\t// juggle args; (a2, a3) may be (dependencies, callback)\n\t\t\t\ta1 = a2;\n\t\t\t\ta2 = a3;\n\t\t\t}\n\t\t\tif(isArray(a1)){\n\t\t\t\t// signature is (requestList [,callback])\n\t\t\t\tif(!a1.length){\n\t\t\t\t\ta2 && a2();\n\t\t\t\t}else{\n\t\t\t\t\tsyntheticMid = \"require*\" + uid();\n\n\t\t\t\t\t// resolve the request list with respect to the reference module\n\t\t\t\t\tfor(var mid, deps = [], i = 0; i < a1.length;){\n\t\t\t\t\t\tmid = a1[i++];\n\t\t\t\t\t\tdeps.push(getModule(mid, referenceModule));\n\t\t\t\t\t}\n\n\t\t\t\t\t// construct a synthetic module to control execution of the requestList, and, optionally, callback\n\t\t\t\t\tmodule = mix(makeModuleInfo(\"\", syntheticMid, 0, \"\"), {\n\t\t\t\t\t\tinjected: arrived,\n\t\t\t\t\t\tdeps: deps,\n\t\t\t\t\t\tdef: a2 || noop,\n\t\t\t\t\t\trequire: referenceModule ? referenceModule.require : req,\n\t\t\t\t\t\tgc: 1 //garbage collect\n\t\t\t\t\t});\n\t\t\t\t\tmodules[module.mid] = module;\n\n\t\t\t\t\t// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies\n\t\t\t\t\tinjectDependencies(module);\n\n\t\t\t\t\t// try to immediately execute\n\t\t\t\t\t// if already traversing a factory tree, then strict causes circular dependency to abort the execution; maybe\n\t\t\t\t\t// it's possible to execute this require later after the current traversal completes and avoid the circular dependency.\n\t\t\t\t\t// ...but *always* insist on immediate in synch mode\n\t\t\t\t\tvar strict = checkCompleteGuard && legacyMode!=sync;\n\t\t\t\t\tguardCheckComplete(function(){\n\t\t\t\t\t\texecModule(module, strict);\n\t\t\t\t\t});\n\t\t\t\t\tif(!module.executed){\n\t\t\t\t\t\t// some deps weren't on board or circular dependency detected and strict; therefore, push into the execQ\n\t\t\t\t\t\texecQ.push(module);\n\t\t\t\t\t}\n\t\t\t\t\tcheckComplete();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn contextRequire;\n\t\t},\n\n\t\tcreateRequire = function(module){\n\t\t\tif(!module){\n\t\t\t\treturn req;\n\t\t\t}\n\t\t\tvar result = module.require;\n\t\t\tif(!result){\n\t\t\t\tresult = function(a1, a2, a3){\n\t\t\t\t\treturn contextRequire(a1, a2, a3, module, result);\n\t\t\t\t};\n\t\t\t\tmodule.require = mix(result, req);\n\t\t\t\tresult.module = module;\n\t\t\t\tresult.toUrl = function(name){\n\t\t\t\t\treturn toUrl(name, module);\n\t\t\t\t};\n\t\t\t\tresult.toAbsMid = function(mid){\n\t\t\t\t\treturn toAbsMid(mid, module);\n\t\t\t\t};\n\t\t\t\tif(has(\"dojo-undef-api\")){\n\t\t\t\t\tresult.undef = function(mid){\n\t\t\t\t\t\treq.undef(mid, module);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif(has(\"dojo-sync-loader\")){\n\t\t\t\t\tresult.syncLoadNls = function(mid){\n\t\t\t\t\t\tvar nlsModuleInfo = getModuleInfo(mid, module),\n\t\t\t\t\t\t\tnlsModule = modules[nlsModuleInfo.mid];\n\t\t\t\t\t\tif(!nlsModule || !nlsModule.executed){\n\t\t\t\t\t\t\tcached = cache[nlsModuleInfo.mid] || cache[urlKeyPrefix + nlsModuleInfo.url];\n\t\t\t\t\t\t\tif(cached){\n\t\t\t\t\t\t\t\tevalModuleText(cached);\n\t\t\t\t\t\t\t\tnlsModule = modules[nlsModuleInfo.mid];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn nlsModule && nlsModule.executed && nlsModule.result;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\n\t\texecQ =\n\t\t\t// The list of modules that need to be evaluated.\n\t\t\t[],\n\n\t\tdefQ =\n\t\t\t// The queue of define arguments sent to loader.\n\t\t\t[],\n\n\t\twaiting =\n\t\t\t// The set of modules upon which the loader is waiting for definition to arrive\n\t\t\t{},\n\n\t\tsetRequested = function(module){\n\t\t\tmodule.injected = requested;\n\t\t\twaiting[module.mid] = 1;\n\t\t\tif(module.url){\n\t\t\t\twaiting[module.url] = module.pack || 1;\n\t\t\t}\n\t\t\tstartTimer();\n\t\t},\n\n\t\tsetArrived = function(module){\n\t\t\tmodule.injected = arrived;\n\t\t\tdelete waiting[module.mid];\n\t\t\tif(module.url){\n\t\t\t\tdelete waiting[module.url];\n\t\t\t}\n\t\t\tif(isEmpty(waiting)){\n\t\t\t\tclearTimer();\n\t\t\t\thas(\"dojo-sync-loader\") && legacyMode==xd && (legacyMode = sync);\n\t\t\t}\n\t\t},\n\n\t\texecComplete = req.idle =\n\t\t\t// says the loader has completed (or not) its work\n\t\t\tfunction(){\n\t\t\t\treturn !defQ.length && isEmpty(waiting) && !execQ.length && !checkCompleteGuard;\n\t\t\t},\n\n\t\trunMapProg = function(targetMid, map){\n\t\t\t// search for targetMid in map; return the map item if found; falsy otherwise\n\t\t\tif(map){\n\t\t\tfor(var i = 0; i < map.length; i++){\n\t\t\t\tif(map[i][2].test(targetMid)){\n\t\t\t\t\treturn map[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\tcompactPath = function(path){\n\t\t\tvar result = [],\n\t\t\t\tsegment, lastSegment;\n\t\t\tpath = path.replace(/\\\\/g, '/').split('/');\n\t\t\twhile(path.length){\n\t\t\t\tsegment = path.shift();\n\t\t\t\tif(segment==\"..\" && result.length && lastSegment!=\"..\"){\n\t\t\t\t\tresult.pop();\n\t\t\t\t\tlastSegment = result[result.length - 1];\n\t\t\t\t}else if(segment!=\".\"){\n\t\t\t\t\tresult.push(lastSegment= segment);\n\t\t\t\t} // else ignore \".\"\n\t\t\t}\n\t\t\treturn result.join(\"/\");\n\t\t},\n\n\t\tmakeModuleInfo = function(pid, mid, pack, url){\n\t\t\tif(has(\"dojo-sync-loader\")){\n\t\t\t\tvar xd= req.isXdUrl(url);\n\t\t\t\treturn {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0, isXd:xd, isAmd:!!(xd || (packs[pid] && packs[pid].isAmd))};\n\t\t\t}else{\n\t\t\t\treturn {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0};\n\t\t\t}\n\t\t},\n\n\t\tgetModuleInfo_ = function(mid, referenceModule, packs, modules, baseUrl, mapProgs, pathsMapProg, alwaysCreate){\n\t\t\t// arguments are passed instead of using lexical variables so that this function my be used independent of the loader (e.g., the builder)\n\t\t\t// alwaysCreate is useful in this case so that getModuleInfo never returns references to real modules owned by the loader\n\t\t\tvar pid, pack, midInPackage, mapProg, mapItem, url, result, isRelative, requestedMid;\n\t\t\trequestedMid = mid;\n\t\t\tisRelative = /^\\./.test(mid);\n\t\t\tif(/(^\\/)|(\\:)|(\\.js$)/.test(mid) || (isRelative && !referenceModule)){\n\t\t\t\t// absolute path or protocol of .js filetype, or relative path but no reference module and therefore relative to page\n\t\t\t\t// whatever it is, it's not a module but just a URL of some sort\n\t\t\t\t// note: pid===0 indicates the routine is returning an unmodified mid\n\n\t\t\t\treturn makeModuleInfo(0, mid, 0, mid);\n\t\t\t}else{\n\t\t\t\t// relative module ids are relative to the referenceModule; get rid of any dots\n\t\t\t\tmid = compactPath(isRelative ? (referenceModule.mid + \"/../\" + mid) : mid);\n\t\t\t\tif(/^\\./.test(mid)){\n\t\t\t\t\tthrow makeError(\"irrationalPath\", mid);\n\t\t\t\t}\n\t\t\t\t// at this point, mid is an absolute mid\n\n\t\t\t\t// map the mid\n\t\t\t\tif(referenceModule){\n\t\t\t\t\tmapItem = runMapProg(referenceModule.mid, mapProgs);\n\t\t\t\t}\n\t\t\t\tmapItem = mapItem || mapProgs.star;\n\t\t\t\tmapItem = mapItem && runMapProg(mid, mapItem[1]);\n\n\t\t\t\tif(mapItem){\n\t\t\t\t\tmid = mapItem[1] + mid.substring(mapItem[3]);\n\t\t\t\t\t}\n\n\t\t\t\tmatch = mid.match(/^([^\\/]+)(\\/(.+))?$/);\n\t\t\t\tpid = match ? match[1] : \"\";\n\t\t\t\tif((pack = packs[pid])){\n\t\t\t\t\tmid = pid + \"/\" + (midInPackage = (match[3] || pack.main));\n\t\t\t\t}else{\n\t\t\t\t\tpid = \"\";\n\t\t\t\t}\n\n\t\t\t\t// search aliases\n\t\t\t\tvar candidateLength = 0,\n\t\t\t\t\tcandidate = 0;\n\t\t\t\tforEach(aliases, function(pair){\n\t\t\t\t\tvar match = mid.match(pair[0]);\n\t\t\t\t\tif(match && match.length>candidateLength){\n\t\t\t\t\t\tcandidate = isFunction(pair[1]) ? mid.replace(pair[0], pair[1]) : pair[1];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(candidate){\n\t\t\t\t\treturn getModuleInfo_(candidate, 0, packs, modules, baseUrl, mapProgs, pathsMapProg, alwaysCreate);\n\t\t\t\t}\n\n\t\t\t\tresult = modules[mid];\n\t\t\t\tif(result){\n\t\t\t\t\treturn alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url) : modules[mid];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// get here iff the sought-after module does not yet exist; therefore, we need to compute the URL given the\n\t\t\t// fully resolved (i.e., all relative indicators and package mapping resolved) module id\n\n\t\t\t// note: pid!==0 indicates the routine is returning a url that has .js appended unmodified mid\n\t\t\tmapItem = runMapProg(mid, pathsMapProg);\n\t\t\tif(mapItem){\n\t\t\t\turl = mapItem[1] + mid.substring(mapItem[3]);\n\t\t\t}else if(pid){\n\t\t\t\turl = pack.location + \"/\" + midInPackage;\n\t\t\t}else if(has(\"config-tlmSiblingOfDojo\")){\n\t\t\t\turl = \"../\" + mid;\n\t\t\t}else{\n\t\t\t\turl = mid;\n\t\t\t}\n\t\t\t// if result is not absolute, add baseUrl\n\t\t\tif(!(/(^\\/)|(\\:)/.test(url))){\n\t\t\t\turl = baseUrl + url;\n\t\t\t}\n\t\t\turl += \".js\";\n\t\t\treturn makeModuleInfo(pid, mid, pack, compactPath(url));\n\t\t},\n\n\t\tgetModuleInfo = function(mid, referenceModule){\n\t\t\treturn getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, mapProgs, pathsMapProg);\n\t\t},\n\n\t\tresolvePluginResourceId = function(plugin, prid, referenceModule){\n\t\t\treturn plugin.normalize ? plugin.normalize(prid, function(mid){return toAbsMid(mid, referenceModule);}) : toAbsMid(prid, referenceModule);\n\t\t},\n\n\t\tdynamicPluginUidGenerator = 0,\n\n\t\tgetModule = function(mid, referenceModule, immediate){\n\t\t\t// compute and optionally construct (if necessary) the module implied by the mid with respect to referenceModule\n\t\t\tvar match, plugin, prid, result;\n\t\t\tmatch = mid.match(/^(.+?)\\!(.*)$/);\n\t\t\tif(match){\n\t\t\t\t// name was <plugin-module>!<plugin-resource-id>\n\t\t\t\tplugin = getModule(match[1], referenceModule, immediate);\n\n\t\t\t\tif(has(\"dojo-sync-loader\") && legacyMode == sync && !plugin.executed){\n\t\t\t\t\tinjectModule(plugin);\n\t\t\t\t\tif(plugin.injected===arrived && !plugin.executed){\n\t\t\t\t\t\tguardCheckComplete(function(){\n\t\t\t\t\t\t\texecModule(plugin);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif(plugin.executed){\n\t\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// we are in xdomain mode for some reason\n\t\t\t\t\t\texecQ.unshift(plugin);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\n\t\t\t\tif(plugin.executed === executed && !plugin.load){\n\t\t\t\t\t// executed the module not knowing it was a plugin\n\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t}\n\n\t\t\t\t// if the plugin has not been loaded, then can't resolve the prid and  must assume this plugin is dynamic until we find out otherwise\n\t\t\t\tif(plugin.load){\n\t\t\t\t\tprid = resolvePluginResourceId(plugin, match[2], referenceModule);\n\t\t\t\t\tmid = (plugin.mid + \"!\" + (plugin.dynamic ? ++dynamicPluginUidGenerator + \"!\" : \"\") + prid);\n\t\t\t\t}else{\n\t\t\t\t\tprid = match[2];\n\t\t\t\t\tmid = plugin.mid + \"!\" + (++dynamicPluginUidGenerator) + \"!waitingForPlugin\";\n\t\t\t\t}\n\t\t\t\tresult = {plugin:plugin, mid:mid, req:createRequire(referenceModule), prid:prid};\n\t\t\t}else{\n\t\t\t\tresult = getModuleInfo(mid, referenceModule);\n\t\t\t}\n\t\t\treturn modules[result.mid] || (!immediate && (modules[result.mid] = result));\n\t\t},\n\n\t\ttoAbsMid = req.toAbsMid = function(mid, referenceModule){\n\t\t\treturn getModuleInfo(mid, referenceModule).mid;\n\t\t},\n\n\t\ttoUrl = req.toUrl = function(name, referenceModule){\n\t\t\tvar moduleInfo = getModuleInfo(name+\"/x\", referenceModule),\n\t\t\t\turl= moduleInfo.url;\n\t\t\treturn fixupUrl(moduleInfo.pid===0 ?\n\t\t\t\t// if pid===0, then name had a protocol or absolute path; either way, toUrl is the identify function in such cases\n\t\t\t\tname :\n\t\t\t\t// \"/x.js\" since getModuleInfo automatically appends \".js\" and we appended \"/x\" to make name look likde a module id\n\t\t\t\turl.substring(0, url.length-5)\n\t\t\t);\n\t\t},\n\n\t\tnonModuleProps = {\n\t\t\tinjected: arrived,\n\t\t\texecuted: executed,\n\t\t\tdef: nonmodule,\n\t\t\tresult: nonmodule\n\t\t},\n\n\t\tmakeCjs = function(mid){\n\t\t\treturn modules[mid] = mix({mid:mid}, nonModuleProps);\n\t\t},\n\n\t\tcjsRequireModule = makeCjs(\"require\"),\n\t\tcjsExportsModule = makeCjs(\"exports\"),\n\t\tcjsModuleModule = makeCjs(\"module\"),\n\n\t\trunFactory = function(module, args){\n\t\t\treq.trace(\"loader-run-factory\", [module.mid]);\n\t\t\tvar factory = module.def,\n\t\t\t\tresult;\n\t\t\thas(\"dojo-sync-loader\") && syncExecStack.unshift(module);\n\t\t\tif(has(\"config-dojo-loader-catches\")){\n\t\t\t\ttry{\n\t\t\t\t\tresult= isFunction(factory) ? factory.apply(null, args) : factory;\n\t\t\t\t}catch(e){\n\t\t\t\t\tsignal(error, module.result = makeError(\"factoryThrew\", [module, e]));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tresult= isFunction(factory) ? factory.apply(null, args) : factory;\n\t\t\t}\n\t\t\tmodule.result = result===undefined && module.cjs ? module.cjs.exports : result;\n\t\t\thas(\"dojo-sync-loader\") && syncExecStack.shift(module);\n\t\t},\n\n\t\tabortExec = {},\n\n\t\tdefOrder = 0,\n\n\t\tpromoteModuleToPlugin = function(pluginModule){\n\t\t\tvar plugin = pluginModule.result;\n\t\t\tpluginModule.dynamic = plugin.dynamic;\n\t\t\tpluginModule.normalize = plugin.normalize;\n\t\t\tpluginModule.load = plugin.load;\n\t\t\treturn pluginModule;\n\t\t},\n\n\t\tresolvePluginLoadQ = function(plugin){\n\t\t\t// plugins is a newly executed module that has a loadQ waiting to run\n\n\t\t\t// step 1: traverse the loadQ and fixup the mid and prid; remember the map from original mid to new mid\n\t\t\t// recall the original mid was created before the plugin was on board and therefore it was impossible to\n\t\t\t// compute the final mid; accordingly, prid may or may not change, but the mid will definitely change\n\t\t\tvar map = {};\n\t\t\tforEach(plugin.loadQ, function(pseudoPluginResource){\n\t\t\t\t// manufacture and insert the real module in modules\n\t\t\t\tvar prid = resolvePluginResourceId(plugin, pseudoPluginResource.prid, pseudoPluginResource.req.module),\n\t\t\t\t\tmid = plugin.dynamic ? pseudoPluginResource.mid.replace(/waitingForPlugin$/, prid) : (plugin.mid + \"!\" + prid),\n\t\t\t\t\tpluginResource = mix(mix({}, pseudoPluginResource), {mid:mid, prid:prid, injected:0});\n\t\t\t\tif(!modules[mid]){\n\t\t\t\t\t// create a new (the real) plugin resource and inject it normally now that the plugin is on board\n\t\t\t\t\tinjectPlugin(modules[mid] = pluginResource);\n\t\t\t\t} // else this was a duplicate request for the same (plugin, rid) for a nondynamic plugin\n\n\t\t\t\t// pluginResource is really just a placeholder with the wrong mid (because we couldn't calculate it until the plugin was on board)\n\t\t\t\t// mark is as arrived and delete it from modules; the real module was requested above\n\t\t\t\tmap[pseudoPluginResource.mid] = modules[mid];\n\t\t\t\tsetArrived(pseudoPluginResource);\n\t\t\t\tdelete modules[pseudoPluginResource.mid];\n\t\t\t});\n\t\t\tplugin.loadQ = 0;\n\n\t\t\t// step2: replace all references to any placeholder modules with real modules\n\t\t\tvar substituteModules = function(module){\n\t\t\t\tfor(var replacement, deps = module.deps || [], i = 0; i<deps.length; i++){\n\t\t\t\t\treplacement = map[deps[i].mid];\n\t\t\t\t\tif(replacement){\n\t\t\t\t\t\tdeps[i] = replacement;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor(var p in modules){\n\t\t\t\tsubstituteModules(modules[p]);\n\t\t\t}\n\t\t\tforEach(execQ, substituteModules);\n\t\t},\n\n\t\tfinishExec = function(module){\n\t\t\treq.trace(\"loader-finish-exec\", [module.mid]);\n\t\t\tmodule.executed = executed;\n\t\t\tmodule.defOrder = defOrder++;\n\t\t\thas(\"dojo-sync-loader\") && forEach(module.provides, function(cb){ cb(); });\n\t\t\tif(module.loadQ){\n\t\t\t\t// the module was a plugin\n\t\t\t\tpromoteModuleToPlugin(module);\n\t\t\t\tresolvePluginLoadQ(module);\n\t\t\t}\n\t\t\t// remove all occurences of this module from the execQ\n\t\t\tfor(i = 0; i < execQ.length;){\n\t\t\t\tif(execQ[i] === module){\n\t\t\t\t\texecQ.splice(i, 1);\n\t\t\t\t}else{\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// delete references to synthetic modules\n\t\t\tif (/^require\\*/.test(module.mid)) {\n\t\t\t\tdelete modules[module.mid];\n\t\t\t}\n\t\t},\n\n\t\tcircleTrace = [],\n\n\t\texecModule = function(module, strict){\n\t\t\t// run the dependency vector, then run the factory for module\n\t\t\tif(module.executed === executing){\n\t\t\t\treq.trace(\"loader-circular-dependency\", [circleTrace.concat(module.mid).join(\"->\")]);\n\t\t\t\treturn (!module.def || strict) ? abortExec :  (module.cjs && module.cjs.exports);\n\t\t\t}\n\t\t\t// at this point the module is either not executed or fully executed\n\n\n\t\t\tif(!module.executed){\n\t\t\t\tif(!module.def){\n\t\t\t\t\treturn abortExec;\n\t\t\t\t}\n\t\t\t\tvar mid = module.mid,\n\t\t\t\t\tdeps = module.deps || [],\n\t\t\t\t\targ, argResult,\n\t\t\t\t\targs = [],\n\t\t\t\t\ti = 0;\n\n\t\t\t\tif(has(\"dojo-trace-api\")){\n\t\t\t\t\tcircleTrace.push(mid);\n\t\t\t\t\treq.trace(\"loader-exec-module\", [\"exec\", circleTrace.length, mid]);\n\t\t\t\t}\n\n\t\t\t\t// for circular dependencies, assume the first module encountered was executed OK\n\t\t\t\t// modules that circularly depend on a module that has not run its factory will get\n\t\t\t\t// the premade cjs.exports===module.result. They can take a reference to this object and/or\n\t\t\t\t// add properties to it. When the module finally runs its factory, the factory can\n\t\t\t\t// read/write/replace this object. Notice that so long as the object isn't replaced, any\n\t\t\t\t// reference taken earlier while walking the deps list is still valid.\n\t\t\t\tmodule.executed = executing;\n\t\t\t\twhile(i < deps.length){\n\t\t\t\t\targ = deps[i++];\n\t\t\t\t\targResult = ((arg === cjsRequireModule) ? createRequire(module) :\n\t\t\t\t\t\t\t\t\t((arg === cjsExportsModule) ? module.cjs.exports :\n\t\t\t\t\t\t\t\t\t\t((arg === cjsModuleModule) ? module.cjs :\n\t\t\t\t\t\t\t\t\t\t\texecModule(arg, strict))));\n\t\t\t\t\tif(argResult === abortExec){\n\t\t\t\t\t\tmodule.executed = 0;\n\t\t\t\t\t\treq.trace(\"loader-exec-module\", [\"abort\", mid]);\n\t\t\t\t\t\thas(\"dojo-trace-api\") && circleTrace.pop();\n\t\t\t\t\t\treturn abortExec;\n\t\t\t\t\t}\n\t\t\t\t\targs.push(argResult);\n\t\t\t\t}\n\t\t\t\trunFactory(module, args);\n\t\t\t\tfinishExec(module);\n\t\t\t\thas(\"dojo-trace-api\") && circleTrace.pop();\n\t\t\t}\n\t\t\t// at this point the module is guaranteed fully executed\n\n\t\t\treturn module.result;\n\t\t},\n\n\n\t\tcheckCompleteGuard = 0,\n\n\t\tguardCheckComplete = function(proc){\n\t\t\ttry{\n\t\t\t\tcheckCompleteGuard++;\n\t\t\t\tproc();\n\t\t\t}finally{\n\t\t\t\tcheckCompleteGuard--;\n\t\t\t}\n\t\t\tif(execComplete()){\n\t\t\t\tsignal(\"idle\", []);\n\t\t\t}\n\t\t},\n\n\t\tcheckComplete = function(){\n\t\t\t// keep going through the execQ as long as at least one factory is executed\n\t\t\t// plugins, recursion, cached modules all make for many execution path possibilities\n\t\t\tif(checkCompleteGuard){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tguardCheckComplete(function(){\n\t\t\t\tcheckDojoRequirePlugin();\n\t\t\t\tfor(var currentDefOrder, module, i = 0; i < execQ.length;){\n\t\t\t\t\tcurrentDefOrder = defOrder;\n\t\t\t\t\tmodule = execQ[i];\n\t\t\t\t\texecModule(module);\n\t\t\t\t\tif(currentDefOrder!=defOrder){\n\t\t\t\t\t\t// defOrder was bumped one or more times indicating something was executed (note, this indicates\n\t\t\t\t\t\t// the execQ was modified, maybe a lot (for example a later module causes an earlier module to execute)\n\t\t\t\t\t\tcheckDojoRequirePlugin();\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// nothing happened; check the next module in the exec queue\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\n\tif(has(\"dojo-undef-api\")){\n\t\treq.undef = function(moduleId, referenceModule){\n\t\t\t// In order to reload a module, it must be undefined (this routine) and then re-requested.\n\t\t\t// This is useful for testing frameworks (at least).\n\t\t\tvar module = getModule(moduleId, referenceModule);\n\t\t\tsetArrived(module);\n\t\t\tdelete modules[module.mid];\n\t\t};\n\t}\n\n\tif(has(\"dojo-inject-api\")){\n\t\tif(has(\"dojo-loader-eval-hint-url\")===undefined){\n\t\t\thas.add(\"dojo-loader-eval-hint-url\", 1);\n\t\t}\n\n\t\tvar fixupUrl= function(url){\n\t\t\t\turl += \"\"; // make sure url is a Javascript string (some paths may be a Java string)\n\t\t\t\treturn url + (cacheBust ? ((/\\?/.test(url) ? \"&\" : \"?\") + cacheBust) : \"\");\n\t\t\t},\n\n\t\t\tinjectPlugin = function(\n\t\t\t\tmodule\n\t\t\t){\n\t\t\t\t// injects the plugin module given by module; may have to inject the plugin itself\n\t\t\t\tvar plugin = module.plugin;\n\n\t\t\t\tif(plugin.executed === executed && !plugin.load){\n\t\t\t\t\t// executed the module not knowing it was a plugin\n\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t}\n\n\t\t\t\tvar onLoad = function(def){\n\t\t\t\t\t\tmodule.result = def;\n\t\t\t\t\t\tsetArrived(module);\n\t\t\t\t\t\tfinishExec(module);\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t};\n\n\t\t\t\tif(plugin.load){\n\t\t\t\t\tplugin.load(module.prid, module.req, onLoad);\n\t\t\t\t}else if(plugin.loadQ){\n\t\t\t\t\tplugin.loadQ.push(module);\n\t\t\t\t}else{\n\t\t\t\t\t// the unshift instead of push is important: we don't want plugins to execute as\n\t\t\t\t\t// dependencies of some other module because this may cause circles when the plugin\n\t\t\t\t\t// loadQ is run; also, generally, we want plugins to run early since they may load\n\t\t\t\t\t// several other modules and therefore can potentially unblock many modules\n\t\t\t\t\tplugin.loadQ = [module];\n\t\t\t\t\texecQ.unshift(plugin);\n\t\t\t\t\tinjectModule(plugin);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// for IE, injecting a module may result in a recursive execution if the module is in the cache\n\n\t\t\tcached = 0,\n\n\t\t\tinjectingModule = 0,\n\n\t\t\tinjectingCachedModule = 0,\n\n\t\t\tevalModuleText = function(text, module){\n\t\t\t\t// see def() for the injectingCachedModule bracket; it simply causes a short, safe curcuit\n\t\t\t\tif(has(\"config-stripStrict\")){\n\t\t\t\t\ttext = text.replace(/\"use strict\"/g, '');\n\t\t\t\t}\n\t\t\t\tinjectingCachedModule = 1;\n\t\t\t\tif(has(\"config-dojo-loader-catches\")){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tif(text===cached){\n\t\t\t\t\t\t\tcached.call(null);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treq.eval(text, has(\"dojo-loader-eval-hint-url\") ? module.url : module.mid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tsignal(error, makeError(\"evalModuleThrew\", module));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(text===cached){\n\t\t\t\t\t\tcached.call(null);\n\t\t\t\t\t}else{\n\t\t\t\t\t\treq.eval(text, has(\"dojo-loader-eval-hint-url\") ? module.url : module.mid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinjectingCachedModule = 0;\n\t\t\t},\n\n\t\t\tinjectModule = function(module){\n\t\t\t\t// Inject the module. In the browser environment, this means appending a script element into\n\t\t\t\t// the document; in other environments, it means loading a file.\n\t\t\t\t//\n\t\t\t\t// If in synchronous mode, then get the module synchronously if it's not xdomainLoading.\n\n\t\t\t\tvar mid = module.mid,\n\t\t\t\t\turl = module.url;\n\t\t\t\tif(module.executed || module.injected || waiting[mid] || (module.url && ((module.pack && waiting[module.url]===module.pack) || waiting[module.url]==1))){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsetRequested(module);\n\n\t\t\t\tif(has(\"dojo-combo-api\")){\n\t\t\t\t\tvar viaCombo = 0;\n\t\t\t\t\tif(module.plugin && module.plugin.isCombo){\n\t\t\t\t\t\t// a combo plugin; therefore, must be handled by combo service\n\t\t\t\t\t\t// the prid should have already been converted to a URL (if required by the plugin) during\n\t\t\t\t\t\t// the normalze process; in any event, there is no way for the loader to know how to\n\t\t\t\t\t\t// to the conversion; therefore the third argument is zero\n\t\t\t\t\t\treq.combo.add(module.plugin.mid, module.prid, 0, req);\n\t\t\t\t\t\tviaCombo = 1;\n\t\t\t\t\t}else if(!module.plugin){\n\t\t\t\t\t\tviaCombo = req.combo.add(0, module.mid, module.url, req);\n\t\t\t\t\t}\n\t\t\t\t\tif(viaCombo){\n\t\t\t\t\t\tcomboPending= 1;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(module.plugin){\n\t\t\t\t\tinjectPlugin(module);\n\t\t\t\t\treturn;\n\t\t\t\t} // else a normal module (not a plugin)\n\n\n\t\t\t\tvar onLoadCallback = function(){\n\t\t\t\t\trunDefQ(module);\n\t\t\t\t\tif(module.injected !== arrived){\n\t\t\t\t\t\t// the script that contained the module arrived and has been executed yet\n\t\t\t\t\t\t// nothing was added to the defQ (so it wasn't an AMD module) and the module\n\t\t\t\t\t\t// wasn't marked as arrived by dojo.provide (so it wasn't a v1.6- module);\n\t\t\t\t\t\t// therefore, it must not have been a module; adjust state accordingly\n\t\t\t\t\t\tsetArrived(module);\n\t\t\t\t\t\tmix(module, nonModuleProps);\n\t\t\t\t\t\treq.trace(\"loader-define-nonmodule\", [module.url]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(has(\"dojo-sync-loader\") && legacyMode){\n\t\t\t\t\t\t// must call checkComplete even in for sync loader because we may be in xdomainLoading mode;\n\t\t\t\t\t\t// but, if xd loading, then don't call checkComplete until out of the current sync traversal\n\t\t\t\t\t\t// in order to preserve order of execution of the dojo.required modules\n\t\t\t\t\t\t!syncExecStack.length && checkComplete();\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcheckComplete();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tcached = cache[mid] || cache[urlKeyPrefix + module.url];\n\t\t\t\tif(cached){\n\t\t\t\t\treq.trace(\"loader-inject\", [\"cache\", module.mid, url]);\n\t\t\t\t\tevalModuleText(cached, module);\n\t\t\t\t\tonLoadCallback();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(has(\"dojo-sync-loader\") && legacyMode){\n\t\t\t\t\tif(module.isXd){\n\t\t\t\t\t\t// switch to async mode temporarily; if current legacyMode!=sync, then is must be one of {legacyAsync, xd, false}\n\t\t\t\t\t\tlegacyMode==sync && (legacyMode = xd);\n\t\t\t\t\t\t// fall through and load via script injection\n\t\t\t\t\t}else if(module.isAmd && legacyMode!=sync){\n\t\t\t\t\t\t// fall through and load via script injection\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// mode may be sync, xd/legacyAsync, or async; module may be AMD or legacy; but module is always located on the same domain\n\t\t\t\t\t\tvar xhrCallback = function(text){\n\t\t\t\t\t\t\tif(legacyMode==sync){\n\t\t\t\t\t\t\t\t// the top of syncExecStack gives the current synchronously executing module; the loader needs\n\t\t\t\t\t\t\t\t// to know this if it has to switch to async loading in the middle of evaluating a legacy module\n\t\t\t\t\t\t\t\t// this happens when a modules dojo.require's a module that must be loaded async because it's xdomain\n\t\t\t\t\t\t\t\t// (using unshift/shift because there is no back() methods for Javascript arrays)\n\t\t\t\t\t\t\t\tsyncExecStack.unshift(module);\n\t\t\t\t\t\t\t\tevalModuleText(text, module);\n\t\t\t\t\t\t\t\tsyncExecStack.shift();\n\n\t\t\t\t\t\t\t\t// maybe the module was an AMD module\n\t\t\t\t\t\t\t\trunDefQ(module);\n\n\t\t\t\t\t\t\t\t// legacy modules never get to defineModule() => cjs and injected never set; also evaluation implies executing\n\t\t\t\t\t\t\t\tif(!module.cjs){\n\t\t\t\t\t\t\t\t\tsetArrived(module);\n\t\t\t\t\t\t\t\t\tfinishExec(module);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(module.finish){\n\t\t\t\t\t\t\t\t\t// while synchronously evaluating this module, dojo.require was applied referencing a module\n\t\t\t\t\t\t\t\t\t// that had to be loaded async; therefore, the loader stopped answering all dojo.require\n\t\t\t\t\t\t\t\t\t// requests so they could be answered completely in the correct sequence; module.finish gives\n\t\t\t\t\t\t\t\t\t// the list of dojo.requires that must be re-applied once all target modules are available;\n\t\t\t\t\t\t\t\t\t// make a synthetic module to execute the dojo.require's in the correct order\n\n\t\t\t\t\t\t\t\t\t// compute a guarnateed-unique mid for the synthetic finish module; remember the finish vector; remove it from the reference module\n\t\t\t\t\t\t\t\t\t// TODO: can we just leave the module.finish...what's it hurting?\n\t\t\t\t\t\t\t\t\tvar finishMid = mid + \"*finish\",\n\t\t\t\t\t\t\t\t\t\tfinish = module.finish;\n\t\t\t\t\t\t\t\t\tdelete module.finish;\n\n\t\t\t\t\t\t\t\t\tdef(finishMid, [\"dojo\", (\"dojo/require!\" + finish.join(\",\")).replace(/\\./g, \"/\")], function(dojo){\n\t\t\t\t\t\t\t\t\t\tforEach(finish, function(mid){ dojo.require(mid); });\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t// unshift, not push, which causes the current traversal to be reattempted from the top\n\t\t\t\t\t\t\t\t\texecQ.unshift(getModule(finishMid));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tonLoadCallback();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttext = transformToAmd(module, text);\n\t\t\t\t\t\t\t\tif(text){\n\t\t\t\t\t\t\t\t\tevalModuleText(text, module);\n\t\t\t\t\t\t\t\t\tonLoadCallback();\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t// if transformToAmd returned falsy, then the module was already AMD and it can be script-injected\n\t\t\t\t\t\t\t\t\t// do so to improve debugability(even though it means another download...which probably won't happen with a good browser cache)\n\t\t\t\t\t\t\t\t\tinjectingModule = module;\n\t\t\t\t\t\t\t\t\treq.injectUrl(fixupUrl(url), onLoadCallback, module);\n\t\t\t\t\t\t\t\t\tinjectingModule = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treq.trace(\"loader-inject\", [\"xhr\", module.mid, url, legacyMode!=sync]);\n\t\t\t\t\t\tif(has(\"config-dojo-loader-catches\")){\n\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\treq.getText(url, legacyMode!=sync, xhrCallback);\n\t\t\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t\t\tsignal(error, makeError(\"xhrInjectFailed\", [module, e]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treq.getText(url, legacyMode!=sync, xhrCallback);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} // else async mode or fell through in xdomain loading mode; either way, load by script injection\n\t\t\t\treq.trace(\"loader-inject\", [\"script\", module.mid, url]);\n\t\t\t\tinjectingModule = module;\n\t\t\t\treq.injectUrl(fixupUrl(url), onLoadCallback, module);\n\t\t\t\tinjectingModule = 0;\n\t\t\t},\n\n\t\t\tdefineModule = function(module, deps, def){\n\t\t\t\treq.trace(\"loader-define-module\", [module.mid, deps]);\n\n\t\t\t\tif(has(\"dojo-combo-api\") && module.plugin && module.plugin.isCombo){\n\t\t\t\t\t// the module is a plugin resource loaded by the combo service\n\t\t\t\t\t// note: check for module.plugin should be enough since normal plugin resources should\n\t\t\t\t\t// not follow this path; module.plugin.isCombo is future-proofing belt and suspenders\n\t\t\t\t\tmodule.result = isFunction(def) ? def() : def;\n\t\t\t\t\tsetArrived(module);\n\t\t\t\t\tfinishExec(module);\n\t\t\t\t\treturn module;\n\t\t\t\t};\n\n\t\t\t\tvar mid = module.mid;\n\t\t\t\tif(module.injected === arrived){\n\t\t\t\t\tsignal(error, makeError(\"multipleDefine\", module));\n\t\t\t\t\treturn module;\n\t\t\t\t}\n\t\t\t\tmix(module, {\n\t\t\t\t\tdeps: deps,\n\t\t\t\t\tdef: def,\n\t\t\t\t\tcjs: {\n\t\t\t\t\t\tid: module.mid,\n\t\t\t\t\t\turi: module.url,\n\t\t\t\t\t\texports: (module.result = {}),\n\t\t\t\t\t\tsetExports: function(exports){\n\t\t\t\t\t\t\tmodule.cjs.exports = exports;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tconfig:function(){\n\t\t\t\t\t\t\treturn module.config;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// resolve deps with respect to this module\n\t\t\t\tfor(var i = 0; i < deps.length; i++){\n\t\t\t\t\tdeps[i] = getModule(deps[i], module);\n\t\t\t\t}\n\n\t\t\t\tif(has(\"dojo-sync-loader\") && legacyMode && !waiting[mid]){\n\t\t\t\t\t// the module showed up without being asked for; it was probably in a <script> element\n\t\t\t\t\tinjectDependencies(module);\n\t\t\t\t\texecQ.push(module);\n\t\t\t\t\tcheckComplete();\n\t\t\t\t}\n\t\t\t\tsetArrived(module);\n\n\t\t\t\tif(!isFunction(def) && !deps.length){\n\t\t\t\t\tmodule.result = def;\n\t\t\t\t\tfinishExec(module);\n\t\t\t\t}\n\n\t\t\t\treturn module;\n\t\t\t},\n\n\t\t\trunDefQ = function(referenceModule, mids){\n\t\t\t\t// defQ is an array of [id, dependencies, factory]\n\t\t\t\t// mids (if any) is a vector of mids given by a combo service\n\t\t\t\tvar definedModules = [],\n\t\t\t\t\tmodule, args;\n\t\t\t\twhile(defQ.length){\n\t\t\t\t\targs = defQ.shift();\n\t\t\t\t\tmids && (args[0]= mids.shift());\n\t\t\t\t\t// explicit define indicates possible multiple modules in a single file; delay injecting dependencies until defQ fully\n\t\t\t\t\t// processed since modules earlier in the queue depend on already-arrived modules that are later in the queue\n\t\t\t\t\t// TODO: what if no args[0] and no referenceModule\n\t\t\t\t\tmodule = (args[0] && getModule(args[0])) || referenceModule;\n\t\t\t\t\tdefinedModules.push([module, args[1], args[2]]);\n\t\t\t\t}\n\t\t\t\tconsumePendingCacheInsert(referenceModule);\n\t\t\t\tforEach(definedModules, function(args){\n\t\t\t\t\tinjectDependencies(defineModule.apply(null, args));\n\t\t\t\t});\n\t\t\t};\n\t}\n\n\tvar timerId = 0,\n\t\tclearTimer = noop,\n\t\tstartTimer = noop;\n\tif(has(\"dojo-timeout-api\")){\n\t\t// Timer machinery that monitors how long the loader is waiting and signals an error when the timer runs out.\n\t\tclearTimer = function(){\n\t\t\ttimerId && clearTimeout(timerId);\n\t\t\ttimerId = 0;\n\t\t},\n\n\t\tstartTimer = function(){\n\t\t\tclearTimer();\n\t\t\tif(req.waitms){\n\t\t\t\ttimerId = window.setTimeout(function(){\n\t\t\t\t\tclearTimer();\n\t\t\t\t\tsignal(error, makeError(\"timeout\", waiting));\n\t\t\t\t}, req.waitms);\n\t\t\t}\n\t\t};\n\t}\n\n\tif(has(\"dom\")){\n\t\t// the typically unnecessary !! in front of doc.attachEvent is due to an opera bug; see\t#15096\n\t\thas.add(\"ie-event-behavior\", !!doc.attachEvent && (typeof opera === \"undefined\" || opera.toString() != \"[object Opera]\"));\n\t}\n\n\tif(has(\"dom\") && (has(\"dojo-inject-api\") || has(\"dojo-dom-ready-api\"))){\n\t\tvar domOn = function(node, eventName, ieEventName, handler){\n\t\t\t\t// Add an event listener to a DOM node using the API appropriate for the current browser;\n\t\t\t\t// return a function that will disconnect the listener.\n\t\t\t\tif(!has(\"ie-event-behavior\")){\n\t\t\t\t\tnode.addEventListener(eventName, handler, false);\n\t\t\t\t\treturn function(){\n\t\t\t\t\t\tnode.removeEventListener(eventName, handler, false);\n\t\t\t\t\t};\n\t\t\t\t}else{\n\t\t\t\t\tnode.attachEvent(ieEventName, handler);\n\t\t\t\t\treturn function(){\n\t\t\t\t\t\tnode.detachEvent(ieEventName, handler);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\t\t\twindowOnLoadListener = domOn(window, \"load\", \"onload\", function(){\n\t\t\t\treq.pageLoaded = 1;\n\t\t\t\tdoc.readyState!=\"complete\" && (doc.readyState = \"complete\");\n\t\t\t\twindowOnLoadListener();\n\t\t\t});\n\n\t\tif(has(\"dojo-inject-api\")){\n\t\t\t// if the loader is on the page, there must be at least one script element\n\t\t\t// getting its parent and then doing insertBefore solves the \"Operation Aborted\"\n\t\t\t// error in IE from appending to a node that isn't properly closed; see\n\t\t\t// dojo/tests/_base/loader/requirejs/simple-badbase.html for an example\n\t\t\tvar sibling = doc.getElementsByTagName(\"script\")[0],\n\t\t\t\tinsertPoint= sibling.parentNode;\n\t\t\treq.injectUrl = function(url, callback, owner){\n\t\t\t\t// insert a script element to the insert-point element with src=url;\n\t\t\t\t// apply callback upon detecting the script has loaded.\n\n\t\t\t\tvar node = owner.node = doc.createElement(\"script\"),\n\t\t\t\t\tonLoad = function(e){\n\t\t\t\t\t\te = e || window.event;\n\t\t\t\t\t\tvar node = e.target || e.srcElement;\n\t\t\t\t\t\tif(e.type === \"load\" || /complete|loaded/.test(node.readyState)){\n\t\t\t\t\t\t\tloadDisconnector();\n\t\t\t\t\t\t\terrorDisconnector();\n\t\t\t\t\t\t\tcallback && callback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tloadDisconnector = domOn(node, \"load\", \"onreadystatechange\", onLoad),\n\t\t\t\t\terrorDisconnector = domOn(node, \"error\", \"onerror\", function(e){\n\t\t\t\t\t\tloadDisconnector();\n\t\t\t\t\t\terrorDisconnector();\n\t\t\t\t\t\tsignal(error, makeError(\"scriptError\", [url, e]));\n\t\t\t\t\t});\n\n\t\t\t\tnode.type = \"text/javascript\";\n\t\t\t\tnode.charset = \"utf-8\";\n\t\t\t\tnode.src = url;\n\t\t\t\tinsertPoint.insertBefore(node, sibling);\n\t\t\t\treturn node;\n\t\t\t};\n\t\t}\n\t}\n\n\tif(has(\"dojo-log-api\")){\n\t\treq.log = function(){\n\t\t\ttry{\n\t\t\t\tfor(var i = 0; i < arguments.length; i++){\n\t\t\t\t\tconsole.log(arguments[i]);\n\t\t\t\t}\n\t\t\t}catch(e){}\n\t\t};\n\t}else{\n\t\treq.log = noop;\n\t}\n\n\tif(has(\"dojo-trace-api\")){\n\t\tvar trace = req.trace = function(\n\t\t\tgroup,\t// the trace group to which this application belongs\n\t\t\targs\t// the contents of the trace\n\t\t){\n\t\t\t///\n\t\t\t// Tracing interface by group.\n\t\t\t//\n\t\t\t// Sends the contents of args to the console iff (req.trace.on && req.trace[group])\n\n\t\t\tif(trace.on && trace.group[group]){\n\t\t\t\tsignal(\"trace\", [group, args]);\n\t\t\t\tfor(var arg, dump = [], text= \"trace:\" + group + (args.length ? (\":\" + args[0]) : \"\"), i= 1; i<args.length;){\n\t\t\t\t\targ = args[i++];\n\t\t\t\t\tif(isString(arg)){\n\t\t\t\t\t\ttext += \", \" + arg;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdump.push(arg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treq.log(text);\n\t\t\t\tdump.length && dump.push(\".\");\n\t\t\t\treq.log.apply(req, dump);\n\t\t\t}\n\t\t};\n\t\tmix(trace, {\n\t\t\ton:1,\n\t\t\tgroup:{},\n\t\t\tset:function(group, value){\n\t\t\t\tif(isString(group)){\n\t\t\t\t\ttrace.group[group]= value;\n\t\t\t\t}else{\n\t\t\t\t\tmix(trace.group, group);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\ttrace.set(mix(mix(mix({}, defaultConfig.trace), userConfig.trace), dojoSniffConfig.trace));\n\t\ton(\"config\", function(config){\n\t\t\tconfig.trace && trace.set(config.trace);\n\t\t});\n\t}else{\n\t\treq.trace = noop;\n\t}\n\n\tvar def = function(\n\t\tmid,\t\t  //(commonjs.moduleId, optional) list of modules to be loaded before running factory\n\t\tdependencies, //(array of commonjs.moduleId, optional)\n\t\tfactory\t\t  //(any)\n\t){\n\t\t///\n\t\t// Advises the loader of a module factory. //Implements http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition.\n\t\t///\n\t\t//note\n\t\t// CommonJS factory scan courtesy of http://requirejs.org\n\n\t\tvar arity = arguments.length,\n\t\t\tdefaultDeps = [\"require\", \"exports\", \"module\"],\n\t\t\t// the predominate signature...\n\t\t\targs = [0, mid, dependencies];\n\t\tif(arity==1){\n\t\t\targs = [0, (isFunction(mid) ? defaultDeps : []), mid];\n\t\t}else if(arity==2 && isString(mid)){\n\t\t\targs = [mid, (isFunction(dependencies) ? defaultDeps : []), dependencies];\n\t\t}else if(arity==3){\n\t\t\targs = [mid, dependencies, factory];\n\t\t}\n\n\t\tif(has(\"dojo-amd-factory-scan\") && args[1]===defaultDeps){\n\t\t\targs[2].toString()\n\t\t\t\t.replace(/(\\/\\*([\\s\\S]*?)\\*\\/|\\/\\/(.*)$)/mg, \"\")\n\t\t\t\t.replace(/require\\([\"']([\\w\\!\\-_\\.\\/]+)[\"']\\)/g, function(match, dep){\n\t\t\t\targs[1].push(dep);\n\t\t\t});\n\t\t}\n\n\t\treq.trace(\"loader-define\", args.slice(0, 2));\n\t\tvar targetModule = args[0] && getModule(args[0]),\n\t\t\tmodule;\n\t\tif(targetModule && !waiting[targetModule.mid]){\n\t\t\t// given a mid that hasn't been requested; therefore, defined through means other than injecting\n\t\t\t// consequent to a require() or define() application; examples include defining modules on-the-fly\n\t\t\t// due to some code path or including a module in a script element. In any case,\n\t\t\t// there is no callback waiting to finish processing and nothing to trigger the defQ and the\n\t\t\t// dependencies are never requested; therefore, do it here.\n\t\t\tinjectDependencies(defineModule(targetModule, args[1], args[2]));\n\t\t}else if(!has(\"ie-event-behavior\") || !has(\"host-browser\") || injectingCachedModule){\n\t\t\t// not IE path: anonymous module and therefore must have been injected; therefore, onLoad will fire immediately\n\t\t\t// after script finishes being evaluated and the defQ can be run from that callback to detect the module id\n\t\t\tdefQ.push(args);\n\t\t}else{\n\t\t\t// IE path: possibly anonymous module and therefore injected; therefore, cannot depend on 1-to-1,\n\t\t\t// in-order exec of onLoad with script eval (since it's IE) and must manually detect here\n\t\t\ttargetModule = targetModule || injectingModule;\n\t\t\tif(!targetModule){\n\t\t\t\tfor(mid in waiting){\n\t\t\t\t\tmodule = modules[mid];\n\t\t\t\t\tif(module && module.node && module.node.readyState === 'interactive'){\n\t\t\t\t\t\ttargetModule = module;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(has(\"dojo-combo-api\") && !targetModule){\n\t\t\t\t\tfor(var i = 0; i<combosPending.length; i++){\n\t\t\t\t\t\ttargetModule = combosPending[i];\n\t\t\t\t\t\tif(targetModule.node && targetModule.node.readyState === 'interactive'){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttargetModule= 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(has(\"dojo-combo-api\") && isArray(targetModule)){\n\t\t\t\tinjectDependencies(defineModule(getModule(targetModule.shift()), args[1], args[2]));\n\t\t\t\tif(!targetModule.length){\n\t\t\t\t\tcombosPending.splice(i, 1);\n\t\t\t\t}\n\t\t\t}else if(targetModule){\n\t\t\t\tconsumePendingCacheInsert(targetModule);\n\t\t\t\tinjectDependencies(defineModule(targetModule, args[1], args[2]));\n\t\t\t}else{\n\t\t\t\tsignal(error, makeError(\"ieDefineFailed\", args[0]));\n\t\t\t}\n\t\t\tcheckComplete();\n\t\t}\n\t};\n\tdef.amd = {\n\t\tvendor:\"dojotoolkit.org\"\n\t};\n\n\tif(has(\"dojo-requirejs-api\")){\n\t\treq.def = def;\n\t}\n\n\t// allow config to override default implemention of named functions; this is useful for\n\t// non-browser environments, e.g., overriding injectUrl, getText, log, etc. in node.js, Rhino, etc.\n\t// also useful for testing and monkey patching loader\n\tmix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);\n\n\t// now that req is fully initialized and won't change, we can hook it up to the error signal\n\ton(error, function(arg){\n\t\ttry{\n\t\t\tconsole.error(arg);\n\t\t\tif(arg instanceof Error){\n\t\t\t\tfor(var p in arg){\n\t\t\t\t\tconsole.log(p + \":\", arg[p]);\n\t\t\t\t}\n\t\t\t\tconsole.log(\".\");\n\t\t\t}\n\t\t}catch(e){}\n\t});\n\n\t// always publish these\n\tmix(req, {\n\t\tuid:uid,\n\t\tcache:cache,\n\t\tpacks:packs\n\t});\n\n\n\tif(has(\"dojo-publish-privates\")){\n\t\tmix(req, {\n\t\t\t// these may be interesting to look at when debugging\n\t\t\tpaths:paths,\n\t\t\taliases:aliases,\n\t\t\tmodules:modules,\n\t\t\tlegacyMode:legacyMode,\n\t\t\texecQ:execQ,\n\t\t\tdefQ:defQ,\n\t\t\twaiting:waiting,\n\n\t\t\t// these are used for testing\n\t\t\t// TODO: move testing infrastructure to a different has feature\n\t\t\tpacks:packs,\n\t\t\tmapProgs:mapProgs,\n\t\t\tpathsMapProg:pathsMapProg,\n\t\t\tlistenerQueues:listenerQueues,\n\n\t\t\t// these are used by the builder (at least)\n\t\t\tcomputeMapProg:computeMapProg,\n\t\t\trunMapProg:runMapProg,\n\t\t\tcompactPath:compactPath,\n\t\t\tgetModuleInfo:getModuleInfo_\n\t\t});\n\t}\n\n\t// the loader can be defined exactly once; look for global define which is the symbol AMD loaders are\n\t// *required* to define (as opposed to require, which is optional)\n\tif(global.define){\n\t\tif(has(\"dojo-log-api\")){\n\t\t\tsignal(error, makeError(\"defineAlreadyDefined\", 0));\n\t\t}\n\t\treturn;\n\t}else{\n\t\tglobal.define = def;\n\t\tglobal.require = req;\n\t\tif(has(\"host-node\")){\n\t\t\trequire= req;\n\t\t}\n\t}\n\n\tif(has(\"dojo-combo-api\") && req.combo && req.combo.plugins){\n\t\tvar plugins = req.combo.plugins,\n\t\t\tpluginName;\n\t\tfor(pluginName in plugins){\n\t\t\tmix(mix(getModule(pluginName), plugins[pluginName]), {isCombo:1, executed:\"executed\", load:1});\n\t\t}\n\t}\n\n\tif(has(\"dojo-config-api\")){\n\t\tforEach(delayedModuleConfig, function(c){ config(c); });\n\t\tvar bootDeps = dojoSniffConfig.deps ||\tuserConfig.deps || defaultConfig.deps,\n\t\t\tbootCallback = dojoSniffConfig.callback || userConfig.callback || defaultConfig.callback;\n\t\treq.boot = (bootDeps || bootCallback) ? [bootDeps || [], bootCallback] : 0;\n\t}\n\tif(!has(\"dojo-built\")){\n\t\t!req.async && req([\"dojo\"]);\n\t\treq.boot && req.apply(null, req.boot);\n\t}\n})\n//>>excludeStart(\"replaceLoaderConfig\", kwArgs.replaceLoaderConfig);\n(\n\t// userConfig\n\t(function(){\n\t\t// make sure we're looking at global dojoConfig etc.\n\t\treturn this.dojoConfig || this.djConfig || this.require || {};\n\t})(),\n\n\t// defaultConfig\n\t{\n\t\t// the default configuration for a browser; this will be modified by other environments\n\t\thasCache:{\n\t\t\t\"host-browser\":1,\n\t\t\t\"dom\":1,\n\t\t\t\"dojo-amd-factory-scan\":1,\n\t\t\t\"dojo-loader\":1,\n\t\t\t\"dojo-has-api\":1,\n\t\t\t\"dojo-inject-api\":1,\n\t\t\t\"dojo-timeout-api\":1,\n\t\t\t\"dojo-trace-api\":1,\n\t\t\t\"dojo-log-api\":1,\n\t\t\t\"dojo-dom-ready-api\":1,\n\t\t\t\"dojo-publish-privates\":1,\n\t\t\t\"dojo-config-api\":1,\n\t\t\t\"dojo-sniff\":1,\n\t\t\t\"dojo-sync-loader\":1,\n\t\t\t\"dojo-test-sniff\":1,\n\t\t\t\"config-deferredInstrumentation\":1,\n\t\t\t\"config-useDeferredInstrumentation\":\"report-unhandled-rejections\",\n\t\t\t\"config-tlmSiblingOfDojo\":1\n\t\t},\n\t\tpackages:[{\n\t\t\t// note: like v1.6-, this bootstrap computes baseUrl to be the dojo directory\n\t\t\tname:'dojo',\n\t\t\tlocation:'.'\n\t\t},{\n\t\t\tname:'tests',\n\t\t\tlocation:'./tests'\n\t\t},{\n\t\t\tname:'dijit',\n\t\t\tlocation:'../dijit'\n\t\t},{\n\t\t\tname:'build',\n\t\t\tlocation:'../util/build'\n\t\t},{\n\t\t\tname:'doh',\n\t\t\tlocation:'../util/doh'\n\t\t},{\n\t\t\tname:'dojox',\n\t\t\tlocation:'../dojox'\n\t\t},{\n\t\t\tname:'demos',\n\t\t\tlocation:'../demos'\n\t\t}],\n\t\ttrace:{\n\t\t\t// these are listed so it's simple to turn them on/off while debugging loading\n\t\t\t\"loader-inject\":0,\n\t\t\t\"loader-define\":0,\n\t\t\t\"loader-exec-module\":0,\n\t\t\t\"loader-run-factory\":0,\n\t\t\t\"loader-finish-exec\":0,\n\t\t\t\"loader-define-module\":0,\n\t\t\t\"loader-circular-dependency\":0,\n\t\t\t\"loader-define-nonmodule\":0\n\t\t},\n\t\tasync:0,\n\t\twaitSeconds:15\n\t}\n);\n//>>excludeEnd(\"replaceLoaderConfig\")\n"]],"start1":0,"start2":0,"length1":0,"length2":67261}]],"length":67261}
{"contributors":[],"silentsave":false,"ts":1368881201659,"patch":[[{"diffs":[[0,"\t\treturn;\n\t\t\t\t}\n"],[1,"                console.log(module);\n"],[0,"\t\t\t\tif(has(\"dojo"]],"start1":49362,"start2":49362,"length1":32,"length2":69}]],"length":67298,"saved":false}
{"ts":1368881330061,"patch":[[{"diffs":[[0,"ole.log("],[1,"'module',"],[0,"module);"]],"start1":49398,"start2":49398,"length1":16,"length2":25}]],"length":67307,"saved":false}
{"ts":1368881391608,"patch":[[{"diffs":[[0,"('module"],[1,"---"],[0,"',module"]],"start1":49405,"start2":49405,"length1":16,"length2":19}]],"length":67310,"saved":false}
{"ts":1368881761104,"patch":[[{"diffs":[[0,"\t\t}\n"],[-1,"                console.log('module---',module);\n"],[0,"\t\t\t\t"]],"start1":49374,"start2":49374,"length1":57,"length2":8},{"diffs":[[0,"\t}\n\t\t\t\t\t\t}else{\n"],[1,"                            console.log('module---',module);\n"],[0,"\t\t\t\t\t\t\treq.getTe"]],"start1":52827,"start2":52827,"length1":32,"length2":93}]],"length":67322,"saved":false}
{"ts":1368882046727,"patch":[[{"diffs":[[0,"se{\n"],[-1,"                            console.log('module---',module);\n"],[0,"\t\t\t\t"]],"start1":52839,"start2":52839,"length1":69,"length2":8}]],"length":67261,"saved":false}
{"ts":1368882060465,"patch":[[{"diffs":[[0,"\t\treturn;\n\t\t\t\t}\n"],[1,"                console.log('module---',has(\"dojo-sync-loader\") && legacyMode);\n"],[0,"\t\t\t\tif(has(\"dojo"]],"start1":49362,"start2":49362,"length1":32,"length2":112}]],"length":67341,"saved":false}
{"ts":1368882149378,"patch":[[{"diffs":[[0,"jo-sync-loader\")"],[-1," &&"],[1,","],[0," legacyMode);\n\t\t"]],"start1":49425,"start2":49425,"length1":35,"length2":33}]],"length":67339,"saved":false}
{"ts":1368884233445,"patch":[[{"diffs":[[0,"gacyMode"],[1,",module"],[0,");\n\t\t\t\ti"]],"start1":49445,"start2":49445,"length1":16,"length2":23}]],"length":67346,"saved":false}
{"ts":1368884560106,"patch":[[{"diffs":[[0,"yMode,module"],[1,",dojoConfig"],[0,");\n\t\t\t\tif(ha"]],"start1":49448,"start2":49448,"length1":24,"length2":35}]],"length":67357,"saved":false}
{"ts":1368884643324,"patch":[[{"diffs":[[0,"dule"],[-1,",dojoConfig"],[0,");\n\t"]],"start1":49456,"start2":49456,"length1":19,"length2":8}]],"length":67346,"saved":false}
{"ts":1368885102303,"patch":[[{"diffs":[[0,"function(){\n"],[1,"                console.log('module.deps',module.deps);\n"],[0,"\t\t\t\tforEach("]],"start1":25894,"start2":25894,"length1":24,"length2":80}]],"length":67402,"saved":false}
